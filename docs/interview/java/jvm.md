
## GC算法有哪些
>参考资料:
>https://blog.csdn.net/weixin_42045591/article/details/80629449

引用计数:        
给对象添加一个引用计数器，每过一个引用计数器值就+1，少一个引用就-1。当它的引用变为0时，该对象就不能再被使用。它的实现简单，但是不能解决互相循环引用的问题。     
根搜索:     
以一系列叫“GC Roots”的对象为起点开始向下搜索，走过的路径称为引用链（Reference Chain），当一个对象没有和任何引用链相连时，证明此对象是不可用的，用图论的说法是不可达的。那么它就会被判定为是可回收的对象。   
标记清除:    
它是现代GC算法的思想基础，分为标记和清除两个阶段：先把所有活动的对象标记出来，然后把没有被标记的对象统一清除掉。但是它有两个问题，一是效率问题，两个过程的效率都不高。二是空间问题，清除之后会产生大量不连续的内存。   
复制:   
复制算法是将原有的内存空间分成两块，每次只使用其中的一块。在GC时，将正在使用的内存块中的存活对象复制到未使用的那一块中，然后清除正在使用的内存块中的所有对象，并交换两块内存的角色，完成一次垃圾回收。它比标记-清除算法要高效，但不适用于存活对象较多的内存，因为复制的时候会有较多的时间消耗。它的致命缺点是会有一半的内存浪费。   
标记整理:   
标记整理算法适用于存活对象较多的场合，它的标记阶段和标记-清除算法中的一样。整理阶段是将所有存活的对象压缩到内存的一端，之后清理边界外所有的空间。它的效率也不高。

## java常用的gc

cms:
>参考资料:   
>https://www.iteye.com/blog/zhanjia-2435266 cms回收的步骤
>https://www.jianshu.com/p/d6441e775dd9 cms常规优化方式

1.7常用   
采用内存分代   
划分新生代 老年代 永久代  每次执行回收会标记 计算对象是晋升还是清理   高版本jdk已经不再使用

g1:
>参考资料:https://www.cnblogs.com/yufengzhang/p/10571081.html

1.8常用  
划分区域 + 内存分代
把内存划分成相同大小的区域  每个区域单一职责 可以为 新生代 老年代或者永久代

zgc:
>参考资料:https://www.cnblogs.com/coderw/p/14281528.html

11常用  
通过多重映射  多个虚拟地址映射一个物理地址 来实现不同回收阶段高效的gc
通过染色指针 来记录gc信息 标记信息、分代信息
读屏障 来控制并发操作的时候 等待引用对象处理

zgc流程: 初始标记--> 并发标记 对象重定位 -->再标记 --> 并发转移准备-->初始转移-->并发转移  
zgc stw 只存在初始标记，再标记，初始转移。 


## gc在不同场景下选择 

